%INPUTS:
% fun: the mathematical function for which we want to compute the root
%   note that the output of fun may include the derivative
%   i.e. [fval,dfdx] = fun(x)
%   or not, i.e. fval = fun(x)
% x_guess: the initial guess for Newton:s method
% num_diff_flag: optional input corresponding to whether or not the solver
%   should use numerical differentation to compute the Jacobian or
%   use a Jacobian generated by fun. No input assumes numerical by default
%       true->fun is assumed to return [fval,J]
%       false->fun is assumed to only return fval %OUTPUTS:
%x: the estimate of the root computed by the function
function [x,exitflag] = multi_newton_solver(fun,x_guess,varargin)
    %true if supposed to use analytical jacobian, false otherwise
    use_analytical_jacobian = nargin==3 && varargin{1}(1);

    if size(x_guess,2) > 1
        error('x_guess must be a column vector')
    end
    
    exitflag = 1;
    x = x_guess;
    Bthresh = 1e-14; % Threshold for min distance from zero
    Athresh = 1e-14; % Threshold for min window size
    step_max = 1000; % Max step size for x
    
    counter = 0;
    while counter < 100
        last_x = x;
        if use_analytical_jacobian
            y = fun(x);
            J = approximate_jacobian(fun,x);
        else
            [y, J] = fun(x);
        end
        
        % Zero determinant safeguard
        if det(J*J') == 0
            exitflag = 2;
            break
        end

        x_step = - J\y;
        
        % Large step size safeguard
        if x_step > step_max 
            exitflag = 3;
            break
        end
        
        x = x + x_step;
        counter = counter + 1;
        
        % Normal termination conditions
        if norm(x-last_x) < Athresh
            exitflag = 4;
            break
        end

        if norm(y) < Bthresh
            exitflag = 5;
            break
        end
    end

    if counter >= 100
        exitflag = 6;
    end

    if norm(fun(x)) < Bthresh
        exitflag = 0;
    end
end